<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Diagrama Conceitual (c/ Pré-req) e Matriz Editável (Filhos)</title>
    <style>
        /* --- Estilos Gerais --- */
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 20px;
            background-color: #f0f0f0;
        }

        h1,
        h2 {
            text-align: center;
            color: #333;
        }

        h1 {
            font-size: 1.6em;
            margin-bottom: 5px;
        }

        h2 {
            font-size: 1.3em;
            margin-top: 0;
            margin-bottom: 15px;
        }

        /* --- Layout Superior (Matriz + Tabela) --- */
        .flex-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
            align-items: flex-start;
            width: 95%;
            max-width: 1400px;
            margin-bottom: 30px;
        }

        #matrix-section {
            flex: 1 1 500px;
            margin-right: 20px;
            min-width: 400px;
        }

        #matrix-container {
            width: 100%;
            height: 450px;
            border: 1px solid #ccc;
            background-color: #fff;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            position: relative;
            margin-bottom: 0;
        }

        #priority-section {
            flex: 1 1 350px;
            min-width: 300px;
            display: flex;
            flex-direction: column;
        }

        #priority-table-container {
            width: 100%;
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #ddd;
            background-color: #fff;
            margin-bottom: 10px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        #priority-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
        }

        #priority-table th,
        #priority-table td {
            border: 1px solid #ddd;
            padding: 5px 8px;
            text-align: left;
            white-space: nowrap;
        }

        #priority-table th:first-child,
        #priority-table td:first-child {
            text-align: center;
            width: 35px;
        }

        #priority-table td:nth-child(3),
        #priority-table td:nth-child(4),
        #priority-table td:nth-child(5) {
            text-align: right;
            width: 60px;
        }

        #priority-table th {
            background-color: #f2f2f2;
            position: sticky;
            top: 0;
            z-index: 1;
        }

        #priority-table tbody tr:nth-child(even) {
            background-color: #f9f9f9;
        }

        #priority-explanation {
            font-size: 10px;
            color: #555;
            margin-top: 5px;
            line-height: 1.4;
        }

        /* --- Estilos da Matriz (SVG) --- */
        .matrix-axis path,
        .matrix-axis line {
            fill: none;
            stroke: #555;
            stroke-width: 1px;
            shape-rendering: crispEdges;
        }

        .matrix-axis .tick text {
            font-size: 10px;
            fill: #444;
        }

        .matrix-axis-label {
            font-size: 12px;
            font-weight: 500;
            fill: #333;
            text-anchor: middle;
        }

        .quadrant-line {
            stroke: #aaa;
            stroke-width: 1px;
            stroke-dasharray: 3, 3;
        }

        .matrix-dot {
            stroke: #333;
            stroke-width: 0.5px;
            cursor: move;
            opacity: 0.8;
            transition: opacity 0.2s, r 0.2s;
        }

        .matrix-dot:hover {
            opacity: 1;
            stroke-width: 1.5px;
            r: 7;
        }

        .matrix-dot.dragging {
            opacity: 1;
            stroke: #3498db;
            stroke-width: 1.5px;
        }

        .matrix-dot.current {
            fill: #5DADE2;
        }

        .matrix-dot.proposed {
            fill: #AEB6BF;
        }

        .matrix-label {
            font-size: 9px;
            fill: #333;
            pointer-events: none;
            text-anchor: middle;
            dominant-baseline: central;
            user-select: none;
        }

        /* Tooltip */
        #matrix-tooltip {
            position: absolute;
            opacity: 0;
            background-color: rgba(40, 40, 40, 0.9);
            color: #fff;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 11px;
            pointer-events: none;
            transition: opacity 0.2s ease-out;
            white-space: pre-wrap;
            max-width: 250px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
            z-index: 10;
        }

        #matrix-tooltip strong {
            color: #aed6f1;
        }

        /* --- Link de Pré-requisito mais transparente --- */
        .prerequisite {
            stroke: #8e44ad;
            stroke-width: 1.3px;
            stroke-dasharray: 5, 3;
            opacity: 0.5;
        }

        /* --- Highlight de pontos --- */
        .matrix-dot.highlighted {
            stroke: #FFC300;
            stroke-width: 2.5px;
            opacity: 1;
            filter: url(#matrix-aura);
        }

        .matrix-dot.related {
            stroke: #FFA500;
            stroke-width: 1.5px;
            opacity: 0.9;
        }

        /* --- Diagrama Principal --- */
        #diagram-container {
            width: 95%;
            max-width: 1600px;
            height: 75vh;
            border: 1px solid #ccc;
            overflow: auto;
            background-color: #fdfdfd;
            position: relative;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        #diagram {
            display: block;
            width: 1800px;
            height: 1200px;
            cursor: grab;
        }

        #diagram.grabbing {
            cursor: grabbing;
        }

        .node-group,
        .child-node-group {
            cursor: pointer;
        }

        .node rect,
        .child-node rect {
            stroke-width: 1.5px;
            rx: 5;
            ry: 5;
            shape-rendering: geometricPrecision;
        }

        .node-group.active>rect,
        .child-node-group.active>rect {
            stroke: #3498db;
            stroke-width: 2.5px;
            filter: drop-shadow(3px 5px 2px rgba(0, 0, 0, 0.2));
        }

        .node.current>rect {
            fill: #D6EAF8;
            stroke: #5DADE2;
        }

        .node.proposed>rect {
            fill: #EAECEE;
            stroke: #AEB6BF;
            stroke-dasharray: 5, 5;
        }

        .child-node.current>rect {
            fill: #EBF5FB;
            stroke: #A9CCE3;
        }

        .child-node.proposed>rect {
            fill: #F8F9F9;
            stroke: #D5DBDB;
            stroke-dasharray: 3, 3;
        }

        .node-label,
        .comment-text,
        .metric-tag text {
            pointer-events: none;
            user-select: none;
        }

        .node-label {
            font-size: 11px;
            fill: #1A5276;
            text-anchor: middle;
            font-weight: 600;
        }

        .comment-text {
            font-size: 9.5px;
            fill: #34495E;
            text-anchor: middle;
            font-weight: 400;
        }

        .metric-tag rect {
            rx: 4;
            ry: 4;
            stroke: #444;
            stroke-width: 0.5px;
            shape-rendering: geometricPrecision;
        }

        .metric-impact rect {
            fill: #AED6F1;
        }

        .metric-difficulty rect {
            fill: #F5B7B1;
        }

        .metric-progress rect {
            fill: #A9DFBF;
        }

        .metric-tag text {
            font-size: 9px;
            font-weight: 500;
            fill: #212121;
            text-anchor: middle;
            dominant-baseline: middle;
        }

        .link,
        .mainFlow,
        .childLink {
            fill: none;
            pointer-events: none;
        }

        .link,
        .mainFlow {
            stroke: #555;
            stroke-width: 1.5px;
        }

        .childLink {
            stroke: #aaa;
            stroke-width: 1px;
        }

        /* --- Legendas --- */
        #legend,
        #legend2 {
            position: absolute;
            left: 10px;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            pointer-events: none;
            z-index: 5;
        }

        #legend {
            top: 10px;
            font-size: 11px;
            margin-bottom: 5px;
        }

        #legend2 {
            top: 140px;
            font-size: 11px;
        }

        #legend .legend-item,
        #legend2 .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 4px;
        }

        .legend-color {
            width: 18px;
            height: 12px;
            margin-right: 6px;
            border: 1px solid #555;
        }

        .legend-color.current {
            background-color: #D6EAF8;
        }

        .legend-color.proposed {
            background-color: #EAECEE;
            border-style: dashed;
        }

        .legend-tag-color {
            display: inline-block;
            width: 25px;
            height: 15px;
            margin-right: 6px;
            border-radius: 4px;
            border: 0.5px solid #444;
            vertical-align: middle;
        }

        .legend-tag-color.metric-impact {
            background-color: #AED6F1;
        }

        .legend-tag-color.metric-difficulty {
            background-color: #F5B7B1;
        }

        .legend-tag-color.metric-progress {
            background-color: #A9DFBF;
        }

        .legend-line {
            stroke-linecap: round;
        }

        .prerequisite.legend-line {
            stroke: #8e44ad;
            stroke-dasharray: none;
            stroke-width: 1.5px;
        }

        .mainFlow.legend-line {
            stroke: #555;
            stroke-width: 1.5px;
        }
    </style>
</head>

<body>
    <h1>Precificação Dinâmica - Componentes e Priorização</h1>

    <!-- Layout Superior -->
    <div id="top-section" class="flex-container">
        <!-- Matriz -->
        <div id="matrix-section">
            <h2>Matriz Impacto x Dificuldade (Tarefas)</h2>
            <div id="matrix-container">
                <svg id="impact-difficulty-matrix"></svg>
                <div id="matrix-tooltip"></div>
            </div>
        </div>
        <!-- Tabela de Priorização -->
        <div id="priority-section">
            <h2>Tabela de Priorização</h2>
            <div id="priority-table-container"></div>
            <div id="priority-explanation"></div>
        </div>
    </div>

    <!-- Diagrama Principal -->
    <h2>Diagrama Conceitual Interativo</h2>
    <div id="diagram-container">
        <svg id="diagram"></svg>
        <div id="legend">
            <div><strong>Legenda Diagrama:</strong></div>
            <div class="legend-item">
                <div class="legend-color current"></div> Bloco/Comp. Atual
            </div>
            <div class="legend-item">
                <div class="legend-color proposed"></div> Bloco/Comp. Proposto
            </div>
            <div class="legend-item">
                <svg width="25" height="10" style="margin-right:4px;">
                    <line x1="0" y1="5" x2="20" y2="5" class="mainFlow legend-line"
                        marker-end="url(#mainFlow-arrowhead)"></line>
                </svg> Fluxo Principal
            </div>
            <div class="legend-item">
                <svg width="25" height="10" style="margin-right:4px;">
                    <line x1="0" y1="5" x2="20" y2="5" class="prerequisite legend-line"
                        marker-end="url(#prerequisite-arrowhead)"></line>
                </svg> Pré-requisito
            </div>
        </div>
        <div id="legend2">
            <div><strong>Métricas (Tags):</strong></div>
            <div class="legend-item"><span class="legend-tag-color metric-impact"></span> I: Impacto</div>
            <div class="legend-item"><span class="legend-tag-color metric-difficulty"></span> D: Dificuldade</div>
            <div class="legend-item"><span class="legend-tag-color metric-progress"></span> P: Progresso</div>
        </div>
    </div>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        // --- Configurações Globais ---
        const nodeWidth = 180, childNodeWidth = 160;
        const minNodeHeight = 70, minChildNodeHeight = 60;
        const horizontalSpacing = nodeWidth * 1.6;
        const verticalSpacingBase = 80; // REDUZIDO de 150
        const childVerticalSpacing = 15, verticalExpandSpacing = 25;
        const APPS_SCRIPT_URL = "https://script.google.com/macros/s/AKfycbz7I1Mh_5hvJrHzFJfsf4Cz0zq4v_07MIqbVN0CHaqzEFiejH64px3LukAIUuNJvN1OAA/exec";

        let allNodes = [], allLinks = [], nodeDataMap = new Map();
        let diagramData = { nodes: [], links: [] };
        let highlightedMatrixNodeId = null;

        // --- Tabela de Priorização ---
        function calculatePrioritizationData(nodes) {
            const taskNodes = nodes.filter(d =>
                d.parent && d.impact != null && !isNaN(d.impact)
                && d.difficulty != null && !isNaN(d.difficulty)
            );
            if (!taskNodes.length) return [];
            const taskMap = new Map(taskNodes.map(n => [n.id, n]));
            const dependentsMap = new Map();
            taskNodes.forEach(node => {
                node.pontosTarefa = (node.impact || 0) - (node.difficulty || 0);
                if (node.prerequisites && Array.isArray(node.prerequisites)) {
                    node.prerequisites.forEach(pr => {
                        if (!dependentsMap.has(pr)) dependentsMap.set(pr, []);
                        dependentsMap.get(pr).push(node.id);
                    });
                }
            });
            return taskNodes.map(node => {
                let ptsDep = 0;
                (dependentsMap.get(node.id) || []).forEach(depId => {
                    const dep = taskMap.get(depId);
                    if (dep && dep.pontosTarefa != null) ptsDep += dep.pontosTarefa;
                });
                return {
                    id: node.id,
                    label: node.label.replace(/^\d+\.\s*/, ''),
                    pontosTarefa: node.pontosTarefa,
                    pontosDependentes: ptsDep,
                    pontosTotais: node.pontosTarefa + ptsDep
                };
            });
        }
        function drawPriorityTable() {
            const c = d3.select("#priority-table-container"), e = d3.select("#priority-explanation");
            c.html(""); e.html("");
            const data = calculatePrioritizationData(allNodes);
            if (!data.length) {
                c.text("Não há tarefas com dados de impacto/dificuldade para priorizar.");
                return;
            }
            data.sort((a, b) => b.pontosTotais - a.pontosTotais);
            const table = c.append("table").attr("id", "priority-table"),
                thead = table.append("thead"),
                tbody = table.append("tbody");
            thead.append("tr")
                .selectAll("th")
                .data(["#", "Tarefa", "Pts Task", "Pts Dep.", "Pts Total"])
                .enter().append("th").html(d => d);
            const rows = tbody.selectAll("tr").data(data).enter().append("tr");
            rows.append("td").text((d, i) => i + 1);
            rows.append("td").text(d => d.label).attr("title", d => d.id);
            rows.append("td").text(d => d.pontosTarefa.toFixed(1));
            rows.append("td").text(d => d.pontosDependentes.toFixed(1));
            rows.append("td").text(d => d.pontosTotais.toFixed(1)).style("font-weight", "bold");
            e.html(`
                <strong>Cálculo de Priorização:</strong><br>
                - <strong>Pts Task:</strong> Impacto - Dificuldade.<br>
                - <strong>Pts Dep.:</strong> Soma dos 'Pts Task' de tarefas dependentes diretas.<br>
                - <strong>Pts Total:</strong> Pts Task + Pts Dep.
            `);
        }

        // --- Matriz Impacto x Dificuldade ---
        function drawImpactDifficultyMatrix() {
            const mc = d3.select("#matrix-container"),
                svg = d3.select("#impact-difficulty-matrix"),
                tooltip = d3.select("#matrix-tooltip");
            svg.selectAll("*").remove();
            const rect = mc.node().getBoundingClientRect();
            if (!rect.width || !rect.height) return;
            const m = { top: 30, right: 30, bottom: 50, left: 60 },
                w = rect.width - m.left - m.right,
                h = rect.height - m.top - m.bottom;
            const xScale = d3.scaleLinear().domain([0, 10.5]).range([0, w]),
                yScale = d3.scaleLinear().domain([0, 10.5]).range([h, 0]);
            const defs = svg.append("defs");
            defs.append("marker")
                .attr("id", "matrix-prerequisite-arrowhead")
                .attr("viewBox", "0 -5 10 10")
                .attr("refX", 5).attr("refY", 0)
                .attr("markerWidth", 4).attr("markerHeight", 4)
                .attr("orient", "auto-start-reverse")
                .append("path")
                .attr("d", "M0,-5L10,0L0,5")
                .attr("fill", "#8e44ad");
            const filter = defs.append("filter")
                .attr("id", "matrix-aura")
                .attr("x", "-50%").attr("y", "-50%")
                .attr("width", "200%").attr("height", "200%");
            filter.append("feGaussianBlur")
                .attr("in", "SourceGraphic")
                .attr("stdDeviation", 2.5)
                .attr("result", "blur");
            filter.append("feFlood")
                .attr("flood-color", "#FFC300")
                .attr("flood-opacity", "1")
                .attr("result", "color");
            filter.append("feComposite")
                .attr("in", "color")
                .attr("in2", "blur")
                .attr("operator", "in")
                .attr("result", "shadow");
            const merge = filter.append("feMerge");
            merge.append("feMergeNode").attr("in", "shadow");
            merge.append("feMergeNode").attr("in", "SourceGraphic");

            const g = svg.append("g").attr("transform", `translate(${m.left},${m.top})`);
            g.append("g").attr("class", "matrix-axis matrix-axis-x")
                .attr("transform", `translate(0,${h})`)
                .call(d3.axisBottom(xScale).ticks(10).tickSizeOuter(0));
            g.append("g").attr("class", "matrix-axis matrix-axis-y")
                .call(d3.axisLeft(yScale).ticks(10).tickSizeOuter(0));
            svg.append("text")
                .attr("class", "matrix-axis-label")
                .attr("x", m.left + w / 2)
                .attr("y", m.top + h + 35)
                .text("Dificuldade Percebida (0-10)");
            svg.append("text")
                .attr("class", "matrix-axis-label")
                .attr("transform", `translate(${m.left - 40},${m.top + h / 2}) rotate(-90)`)
                .text("Impacto Percebido (0-10)");
            const mid = 5;
            g.append("line").attr("class", "quadrant-line")
                .attr("x1", xScale(mid)).attr("y1", 0)
                .attr("x2", xScale(mid)).attr("y2", h);
            g.append("line").attr("class", "quadrant-line")
                .attr("x1", 0).attr("y1", yScale(mid))
                .attr("x2", w).attr("y2", yScale(mid));

            const matrixData = allNodes.filter(d =>
                d.parent && d.impact != null && !isNaN(d.impact)
                && d.difficulty != null && !isNaN(d.difficulty)
            );
            const matrixMap = new Map(matrixData.map(n => [n.id, n]));

            // Tooltip handlers
            const over = (e, d) => {
                d3.select(e.currentTarget).raise()
                    .transition().duration(100)
                    .attr("r", 8).style("stroke-width", "1.5px");
                tooltip.transition().duration(100).style("opacity", 0.9);
                let html = `<strong>${d.label || 'N/A'}</strong> (${d.id})<br/>`;
                html += `Impacto: ${d.impact.toFixed(1)}<br/>`;
                html += `Dificuldade: ${d.difficulty.toFixed(1)}<br/>`;
                html += `Progresso: ${d.progress != null ? d.progress + '%' : 'N/A'}<br/>`;
                if (d.comment) html += `<em>"${d.comment.replace(/\n/g, '<br/>')}"</em>`;
                tooltip.html(html);
            };
            const move = (e, d) => {
                tooltip.style("left", (e.clientX + 15) + "px")
                    .style("top", (e.clientY - 25) + "px");
            };
            const out = (e, d) => {
                d3.select(e.currentTarget)
                    .transition().duration(100)
                    .attr("r", 6).style("stroke-width", "0.5px");
                tooltip.transition().duration(200).style("opacity", 0);
            };

            // Drag handlers
            const dragStart = (e, d) => {
                d3.select(e.currentTarget).raise().classed("dragging", true);
                tooltip.style("opacity", 0);
            };
            const dragging = (e, d) => {
                const [px, py] = d3.pointer(e, g.node());
                let nd = xScale.invert(px), ni = yScale.invert(py);
                nd = Math.round(Math.max(0, Math.min(10, nd)) * 10) / 10;
                ni = Math.round(Math.max(0, Math.min(10, ni)) * 10) / 10;
                const node = findNodeById(d.id);
                if (node) { node.difficulty = nd; node.impact = ni; d.difficulty = nd; d.impact = ni; }
                d3.select(e.currentTarget)
                    .attr("cx", xScale(d.difficulty))
                    .attr("cy", yScale(d.impact));
                g.select(`#matrix-label-${d.id}`)
                    .attr("x", xScale(d.difficulty))
                    .attr("y", yScale(d.impact));
                updateMatrixDependencyLinks(d.id);
            };
            const dragEnd = (e, d) => {
                d3.select(e.currentTarget).classed("dragging", false);
                if (d.parent) {
                    updateDiagram();
                    drawPriorityTable();
                    saveDataToSheet(d);
                } else {
                    updateDiagram();
                    drawPriorityTable();
                }
            };

            // Click highlight
            const clickDot = (e, d) => {
                e.stopPropagation();
                g.selectAll(".matrix-dot")
                    .classed("highlighted", false)
                    .classed("related", false)
                    .style("filter", null);
                if (highlightedMatrixNodeId === d.id) {
                    highlightedMatrixNodeId = null;
                } else {
                    highlightedMatrixNodeId = d.id;
                    const rel = new Set([d.id]);
                    if (d.prerequisites) d.prerequisites.forEach(p => { if (matrixMap.has(p)) rel.add(p); });
                    matrixData.forEach(n => { if (n.prerequisites && n.prerequisites.includes(d.id)) rel.add(n.id); });
                    g.selectAll(".matrix-dot")
                        .filter(n => rel.has(n.id))
                        .classed("highlighted", n => n.id === d.id)
                        .classed("related", n => n.id !== d.id)
                        .style("filter", n => n.id === d.id ? "url(#matrix-aura)" : null)
                        .raise();
                }
            };
            svg.on("click", () => {
                if (highlightedMatrixNodeId) {
                    g.selectAll(".matrix-dot")
                        .classed("highlighted", false)
                        .classed("related", false)
                        .style("filter", null);
                    highlightedMatrixNodeId = null;
                }
            });

            // Desenha pontos
            const dots = g.selectAll(".matrix-dot").data(matrixData, d => d.id);
            dots.exit().remove();
            dots.enter().append("circle")
                .attr("id", d => `matrix-dot-${d.id}`)
                .attr("class", d => `matrix-dot ${d.type}`)
                .attr("cx", d => xScale(d.difficulty))
                .attr("cy", d => yScale(d.impact))
                .attr("r", 0)
                .call(d3.drag()
                    .on("start", dragStart)
                    .on("drag", dragging)
                    .on("end", dragEnd))
                .on("mouseover", over)
                .on("mousemove", move)
                .on("mouseout", out)
                .on("click", clickDot)
                .merge(dots)
                .transition().duration(500)
                .attr("cx", d => xScale(d.difficulty))
                .attr("cy", d => yScale(d.impact))
                .attr("r", 6);

            // Labels
            const labels = g.selectAll(".matrix-label").data(matrixData, d => d.id);
            labels.exit().remove();
            labels.enter().append("text")
                .attr("class", "matrix-label")
                .attr("id", d => `matrix-label-${d.id}`)
                .attr("x", d => xScale(d.difficulty))
                .attr("y", d => yScale(d.impact))
                .attr("dy", -10)
                .style("opacity", 0)
                .text(d => {
                    const t = d.label.replace(/^\d+\.\s*/, '');
                    return t.length > 15 ? t.slice(0, 12) + "..." : t;
                })
                .merge(labels)
                .transition().duration(500).delay(100)
                .attr("x", d => xScale(d.difficulty))
                .attr("y", d => yScale(d.impact))
                .style("opacity", 1);

            // Links de dependência
            function drawMatrixDependencyLinks() {
                const deps = [];
                matrixData.forEach(t => {
                    if (t.prerequisites) t.prerequisites.forEach(s => {
                        const src = matrixMap.get(s);
                        if (src) deps.push({ source: src, target: t, id: `matrix-link-${s}-${t.id}` });
                    });
                });
                const sel = g.selectAll("line.prerequisite").data(deps, d => d.id);
                sel.exit().remove();
                sel.enter().append("line")
                    .attr("class", "prerequisite")
                    .attr("marker-end", "url(#matrix-prerequisite-arrowhead)")
                    .merge(sel)
                    .each(function (d) {
                        const sx = xScale(d.source.difficulty), sy = yScale(d.source.impact),
                            tx = xScale(d.target.difficulty), ty = yScale(d.target.impact),
                            dx = tx - sx, dy = ty - sy, dist = Math.sqrt(dx * dx + dy * dy), r = 6;
                        if (dist === 0) {
                            d3.select(this)
                                .attr("x1", sx).attr("y1", sy)
                                .attr("x2", sx).attr("y2", sy);
                            return;
                        }
                        const ratio = (dist - r - 2) / dist, startRatio = r / dist;
                        const x1 = sx + dx * startRatio, y1 = sy + dy * startRatio,
                            x2 = sx + dx * ratio, y2 = sy + dy * ratio;
                        d3.select(this)
                            .attr("x1", x1).attr("y1", y1)
                            .attr("x2", x2).attr("y2", y2);
                    });
            }
            function updateMatrixDependencyLinks(id) {
                g.selectAll("line.prerequisite")
                    .filter(d => d.source.id === id || d.target.id === id)
                    .each(function (d) {
                        const sx = xScale(d.source.difficulty), sy = yScale(d.source.impact),
                            tx = xScale(d.target.difficulty), ty = yScale(d.target.impact),
                            dx = tx - sx, dy = ty - sy, dist = Math.sqrt(dx * dx + dy * dy), r = 6;
                        if (dist === 0) return;
                        const ratio = (dist - r - 2) / dist, startRatio = r / dist;
                        const x1 = sx + dx * startRatio, y1 = sy + dy * startRatio,
                            x2 = sx + dx * ratio, y2 = sy + dy * ratio;
                        d3.select(this)
                            .attr("x1", x1).attr("y1", y1)
                            .attr("x2", x2).attr("y2", y2);
                    });
            }
            drawMatrixDependencyLinks();
        }

        // --- Diagrama Principal ---
        const diagramSvg = d3.select("#diagram");
        const diagramG = diagramSvg.append("g");
        const diagramLinkGroup = diagramG.append("g").attr("class", "links");
        const diagramNodeGroup = diagramG.append("g").attr("class", "nodes");
        const diagramZoom = d3.zoom().scaleExtent([0.15, 3])
            .on("start", () => diagramSvg.style("cursor", "grabbing"))
            .on("zoom", event => diagramG.attr("transform", event.transform))
            .on("end", () => diagramSvg.style("cursor", "grab"));
        diagramSvg.call(diagramZoom);

        const diagramDefs = diagramG.append("defs");
        diagramDefs.selectAll("marker")
            .data(["mainFlow-arrowhead", "child-arrowhead", "prerequisite-arrowhead"])
            .enter().append("marker")
            .attr("id", d => d)
            .attr("viewBox", "0 -5 10 10")
            .attr("refX", 6).attr("refY", 0)
            .attr("markerWidth", 6).attr("markerHeight", 6)
            .attr("orient", "auto-start-reverse")
            .append("path")
            .attr("d", "M0,-5L10,0L0,5")
            .attr("fill", d => {
                if (d === "child-arrowhead") return "#aaa";
                if (d === "prerequisite-arrowhead") return "#8e44ad";
                return "#555";
            });

        function processData(data) {
            allNodes = []; nodeDataMap = new Map();
            let currX = horizontalSpacing / 2;
            diagramData.nodes = data.nodes || [];
            diagramData.links = data.links || [];
            allLinks = diagramData.links.filter(l => l.type !== "feedback");
            const mains = diagramData.nodes.sort((a, b) => (a.sequenceOrder || Infinity) - (b.sequenceOrder || Infinity));
            function recurse(n, parent, isTop) {
                if (isTop && n.x === undefined) n.x = currX;
                if (n.y === undefined) n.y = verticalSpacingBase;
                n.parent = parent;
                n._expanded = (n.children && n.children.length > 0 && n._expanded !== false);
                n._hidden = !!parent && !nodeDataMap.get(parent)?._expanded;
                allNodes.push(n); nodeDataMap.set(n.id, n);
                if (isTop) currX += horizontalSpacing;
                if (n.children) n.children.forEach(c => recurse(c, n.id, false));
            }
            mains.forEach(n => recurse(n, null, true));
        }

        function calculateLayout() {
            allNodes.forEach(n => {
                if (n.parent && !n._hidden) {
                    const p = nodeDataMap.get(n.parent);
                    if (!p) return;
                    const ph = p.calculatedHeight || (p.parent ? minChildNodeHeight : minNodeHeight);
                    const siblings = p.children.map(c => nodeDataMap.get(c.id))
                        .filter(x => x && !x._hidden)
                        .sort((a, b) => (a.displayOrder || a.order || 0) - (b.displayOrder || b.order || 0));
                    const idx = siblings.findIndex(x => x.id === n.id);
                    let y = p.y + ph / 2 + verticalExpandSpacing;
                    for (let i = 0; i < idx; i++) {
                        y += (siblings[i].calculatedHeight || minChildNodeHeight) + childVerticalSpacing;
                    }
                    const ch = n.calculatedHeight || minChildNodeHeight;
                    n.x = p.x; n.y = y + ch / 2;
                } else if (!n.parent && n.x === undefined) {
                    const mains = allNodes.filter(x => !x.parent)
                        .sort((a, b) => (a.sequenceOrder || Infinity) - (b.sequenceOrder || Infinity));
                    const idx = mains.findIndex(x => x.id === n.id);
                    n.x = (horizontalSpacing / 2) + (idx * horizontalSpacing);
                    n.y = verticalSpacingBase;
                }
            });
        }

        function wrapText(el, text, width) {
            const node = d3.select(el);
            node.selectAll("tspan").remove();
            if (!text) { node.text(""); return; }
            const lines = text.split("\n"), lh = 1.1;
            lines.forEach((line, i) => {
                const words = line.split(/\s+/).filter(w => w);
                let cur = [], tspan = node.append("tspan").attr("x", 0).attr("dy", i === 0 ? "0em" : `${lh}em`);
                words.forEach(w => {
                    cur.push(w); tspan.text(cur.join(" "));
                    if (tspan.node().getComputedTextLength() > width && cur.length > 1) {
                        cur.pop(); tspan.text(cur.join(" "));
                        cur = [w];
                        tspan = node.append("tspan").attr("x", 0).attr("dy", `${lh}em`).text(w);
                    }
                });
            });
        }

        function updateNodeSize(sel) {
            const th = 18, pg = 4, pX = 15, pYT = 10, pYB = 10, lg = 5;
            sel.each(function (d) {
                const g = d3.select(this),
                    title = g.select("text.node-label"),
                    comment = g.select("text.comment-text"),
                    tBB = title.node().getBBox(),
                    cBB = comment.node().textContent.trim() ? comment.node().getBBox() : { width: 0, height: 0 };
                const isChild = !!d.parent;
                const minW = isChild ? childNodeWidth : nodeWidth,
                    minH = isChild ? minChildNodeHeight : minNodeHeight;
                const hasMetrics = (d.impact != null || d.difficulty != null || d.progress != null);
                const metricsH = hasMetrics ? (th + pYB + pg) : pYB;
                let boxH = pYT + tBB.height + (cBB.height ? lg + cBB.height : 0) + metricsH;
                boxH = Math.max(minH, boxH);
                d.calculatedHeight = boxH;
                const textW = Math.max(tBB.width, cBB.width);
                let boxW = Math.max(minW, textW + pX * 2);
                if (hasMetrics) {
                    const minTagW = 40;
                    const reqW = minTagW * 3 + pg * 2 + pX * 2;
                    boxW = Math.max(boxW, reqW);
                }
                g.select("rect")
                    .attr("width", boxW)
                    .attr("height", boxH)
                    .attr("x", -boxW / 2)
                    .attr("y", -boxH / 2);
                title.attr("y", -boxH / 2 + pYT + tBB.height / 2);
                if (cBB.height) comment.attr("y", -boxH / 2 + pYT + tBB.height + lg + cBB.height / 2);
                if (hasMetrics) {
                    const bY = boxH / 2, tagY = bY - pYB - th / 2,
                        tagW = (boxW - pX * 2 - pg * 2) / 3,
                        xs = [-boxW / 2 + pX + tagW / 2, -boxW / 2 + pX + tagW / 2 + tagW + pg, -boxW / 2 + pX + tagW / 2 + 2 * (tagW + pg)];
                    const grps = [g.select("g.metric-impact"), g.select("g.metric-difficulty"), g.select("g.metric-progress")];
                    const vals = [d.impact, d.difficulty, d.progress];
                    grps.forEach((grp, i) => {
                        if (vals[i] != null) {
                            grp.style("opacity", 1)
                                .attr("transform", `translate(${xs[i]},${tagY})`);
                            grp.select("rect")
                                .attr("width", tagW)
                                .attr("height", th)
                                .attr("x", -tagW / 2)
                                .attr("y", -th / 2);
                            const txt = grp.select("text");
                            if (i < 2) txt.text(`${i === 0 ? "I" : "D"}: ${typeof vals[i] === "number" ? vals[i].toFixed(1) : vals[i]}`);
                            else txt.text(`P: ${vals[i]}%`);
                        } else grp.style("opacity", 0);
                    });
                } else g.selectAll(".metric-tag").style("opacity", 0);
            });
        }

        function updateDiagram() {
            calculateLayout();
            const vis = allNodes.filter(n => !n._hidden),
                links = generateVisibleLinks(vis);
            // Nodes
            const sel = diagramNodeGroup.selectAll("g.node-group").data(vis, d => d.id);
            sel.exit().remove();
            const ent = sel.enter().append("g")
                .attr("class", d => `node-group ${d.parent ? "child-node" : "node"} ${d.type}`)
                .attr("transform", d => `translate(${d.x},${d.y})`)
                .on("click", nodeClicked)
                .call(d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended));
            ent.append("rect");
            ent.append("text").attr("class", "node-label");
            ent.append("text").attr("class", "comment-text");
            ["impact", "difficulty", "progress"].forEach(type => {
                const grp = ent.append("g").attr("class", `metric-tag metric-${type}`);
                grp.append("rect");
                grp.append("text");
            });
            const upd = ent.merge(sel);
            upd.transition().duration(350).attr("transform", d => `translate(${d.x},${d.y})`);
            upd.select("text.node-label").each(function (d) {
                const mw = (d.parent ? childNodeWidth : nodeWidth) - 30;
                wrapText(this, d.label, mw);
            });
            upd.select("text.comment-text").each(function (d) {
                const mw = (d.parent ? childNodeWidth : nodeWidth) - 30;
                wrapText(this, d.comment || "", mw);
            });
            updateNodeSize(upd);
            upd.classed("expanded", d => d._expanded);
            // Links
            const lsel = diagramLinkGroup.selectAll("path").data(links, d => d.id);
            lsel.exit().remove();
            const lent = lsel.enter().append("path")
                .attr("class", d => d.type || "mainFlow")
                .attr("marker-end", d => {
                    const t = d.type || "mainFlow";
                    if (t === "childLink") return "url(#child-arrowhead)";
                    if (t === "prerequisite") return "url(#prerequisite-arrowhead)";
                    return "url(#mainFlow-arrowhead)";
                });
            lent.merge(lsel).transition().duration(350).attr("d", calculateLinkPath);
            adjustDiagramSvgSize();
        }

        function adjustDiagramSvgSize() {
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            let has = false;
            diagramNodeGroup.selectAll("g.node-group").each(function (d) {
                if (d._hidden) return;
                has = true;
                const rect = d3.select(this).select("rect"),
                    h = d.calculatedHeight || minNodeHeight,
                    w = +rect.attr("width") || nodeWidth;
                minX = Math.min(minX, d.x - w / 2);
                maxX = Math.max(maxX, d.x + w / 2);
                minY = Math.min(minY, d.y - h / 2);
                maxY = Math.max(maxY, d.y + h / 2);
            });
            const pad = 60;
            if (has) {
                const totalW = maxX - minX + pad * 2,
                    totalH = maxY - minY + pad * 2;
                diagramSvg
                    .attr("width", Math.max(1800, totalW))
                    .attr("height", Math.max(1200, totalH))
                    .attr("viewBox", `${minX - pad} ${minY - pad} ${totalW} ${totalH}`);
            } else {
                diagramSvg
                    .attr("width", 1800)
                    .attr("height", 1200)
                    .attr("viewBox", "0 0 1800 1200");
            }
        }

        function nodeClicked(event, d) {
            if (event.defaultPrevented) return;
            const n = nodeDataMap.get(d.id);
            if (n && n.children) {
                n._expanded = !n._expanded;
                n.children.forEach(c => {
                    const ch = nodeDataMap.get(c.id);
                    if (ch) ch._hidden = !n._expanded;
                });
                updateDiagram();
            }
        }

        let dragStartX, dragStartY;
        function dragstarted(event, d) {
            event.sourceEvent.stopPropagation();
            diagramSvg.style("cursor", "grabbing");
            dragStartX = event.x; dragStartY = event.y;
            d3.select(this).raise().classed("active", true);
        }
        function dragged(event, d) {
            const n = nodeDataMap.get(d.id);
            if (!n) return;
            const dx = event.x - n.x, dy = event.y - n.y;
            n.x = event.x; n.y = event.y;
            d3.select(this).attr("transform", `translate(${n.x},${n.y})`);
            if (!n.parent && n._expanded) {
                n.children.forEach(c => {
                    const ch = nodeDataMap.get(c.id);
                    if (ch && !ch._hidden) {
                        ch.x += dx; ch.y += dy;
                        diagramNodeGroup.selectAll("g.node-group")
                            .filter(x => x.id === ch.id)
                            .attr("transform", `translate(${ch.x},${ch.y})`);
                    }
                });
            }
            updateVisibleLinks(d.id);
            if (!n.parent && n._expanded) updateVisibleLinks();
        }
        function dragended(event, d) {
            diagramSvg.style("cursor", "grab");
            d3.select(this).classed("active", false);
        }

        function updateVisibleLinks(movedId = null) {
            const vis = allNodes.filter(n => !n._hidden);
            let links = generateVisibleLinks(vis);
            if (movedId) {
                links = links.filter(l => {
                    const s = typeof l.source === "object" ? l.source.id : l.source;
                    const t = typeof l.target === "object" ? l.target.id : l.target;
                    let inc = s === movedId || t === movedId;
                    const mn = nodeDataMap.get(movedId);
                    if (mn && !mn.parent && mn.children) {
                        const chs = new Set(mn.children.map(c => nodeDataMap.get(c.id)?.id).filter(Boolean));
                        if (chs.has(s) || chs.has(t)) inc = true;
                    }
                    return inc;
                });
            }
            diagramLinkGroup.selectAll("path")
                .data(links, d => d.id)
                .attr("d", calculateLinkPath);
        }

        function calculateLinkPath(d) {
            const sid = typeof d.source === "object" ? d.source.id : d.source;
            const tid = typeof d.target === "object" ? d.target.id : d.target;
            const sn = nodeDataMap.get(sid), tn = nodeDataMap.get(tid);
            if (!sn || !tn || sn._hidden || tn._hidden) return "M0,0";
            const sChild = !!sn.parent, tChild = !!tn.parent;
            const sh = sn.calculatedHeight || (sChild ? minChildNodeHeight : minNodeHeight);
            const th = tn.calculatedHeight || (tChild ? minChildNodeHeight : minNodeHeight);
            const sx = sn.x, sy = sn.y, tx = tn.x, ty = tn.y;
            const dx = tx - sx, dy = ty - sy;
            let sxOff = 0, syOff = 0, txOff = 0, tyOff = 0;
            if (d.type === "childLink") {
                syOff = sh / 2; tyOff = -th / 2; sxOff = 0.1; txOff = 0.1;
            } else {
                if (dx === 0 && dy === 0) return "M0,0";
                const angle = Math.atan2(dy, dx), tan = dy / dx;
                if (Math.abs(dy / dx) < sh / (sChild ? childNodeWidth : nodeWidth)) {
                    sxOff = Math.sign(dx) * (sChild ? childNodeWidth : nodeWidth) / 2;
                    syOff = sxOff * tan;
                } else {
                    syOff = Math.sign(dy) * sh / 2;
                    sxOff = syOff / tan;
                }
                if (Math.abs(dy / dx) < th / (tChild ? childNodeWidth : nodeWidth)) {
                    txOff = -Math.sign(dx) * (tChild ? childNodeWidth : nodeWidth) / 2;
                    tyOff = txOff * tan;
                } else {
                    tyOff = -Math.sign(dy) * th / 2;
                    txOff = tyOff / tan;
                }
                sxOff = isFinite(sxOff) ? sxOff : 0;
                syOff = isFinite(syOff) ? syOff : 0;
                txOff = isFinite(txOff) ? txOff : 0;
                tyOff = isFinite(tyOff) ? tyOff : 0;
            }
            const x1 = sx + sxOff, y1 = sy + syOff, x2 = tx + txOff, y2 = ty + tyOff;
            return `M${x1},${y1}L${x2},${y2}`;
        }

        function generateVisibleLinks(vis) {
            const ids = new Set(vis.map(n => n.id));
            const links = [];
            allLinks.forEach(l => {
                if (ids.has(l.source) && ids.has(l.target)) {
                    links.push({ ...l, id: `link-${l.source}-${l.target}-${l.type || 'main'}` });
                }
            });
            vis.filter(n => n._expanded && n.children).forEach(p => {
                const chs = p.children.map(c => nodeDataMap.get(c.id))
                    .filter(x => x && !x._hidden)
                    .sort((a, b) => (a.order || 0) - (b.order || 0));
                chs.forEach((c, i) => {
                    links.push({ source: p.id, target: c.id, type: 'childLink', id: `link-${p.id}-${c.id}-child` });
                    if (p.childrenLayout === 'vertical-sequence' && i < chs.length - 1) {
                        links.push({ source: c.id, target: chs[i + 1].id, type: 'childLink', id: `link-${c.id}-${chs[i + 1].id}-seq` });
                    }
                });
            });
            vis.forEach(n => {
                if (n.prerequisites) n.prerequisites.forEach(pr => {
                    const src = nodeDataMap.get(pr);
                    if (src && ids.has(src.id)) {
                        links.push({ source: src.id, target: n.id, type: 'prerequisite', id: `link-${src.id}-${n.id}-prereq` });
                    }
                });
            });
            return links;
        }

        function findNodeById(id) { return allNodes.find(n => n.id === id); }

        // --- Fetch e Inicialização ---
        function loadDataAndInitialize() {
            const loading = d3.select('body').append('div')
                .attr('id', 'loading-indicator')
                .style('position', 'fixed')
                .style('top', '50%')
                .style('left', '50%')
                .style('transform', 'translate(-50%,-50%)')
                .style('padding', '10px')
                .style('background', 'rgba(0,0,0,0.7)')
                .style('color', '#fff')
                .style('border-radius', '5px')
                .text('Carregando dados...');
            if (!APPS_SCRIPT_URL) {
                alert('Erro: URL do Apps Script não definida.');
                loading.remove();
                return;
            }
            fetch(APPS_SCRIPT_URL)
                .then(r => { if (!r.ok) throw new Error(`HTTP ${r.status}`); return r.json(); })
                .then(data => {
                    if (data.error) {
                        alert(`Erro ao carregar dados: ${data.error}`);
                        diagramData = { nodes: [], links: [] };
                    } else {
                        diagramData = data;
                    }
                })
                .catch(e => {
                    alert(`Falha ao carregar dados: ${e.message}`);
                    diagramData = { nodes: [], links: [] };
                })
                .finally(() => {
                    loading.remove();
                    processData(diagramData);
                    drawImpactDifficultyMatrix();
                    updateDiagram();
                    drawPriorityTable();
                });
        }

        function saveDataToSheet(changed) {
            if (!changed || !changed.id || changed.impact == null || changed.difficulty == null) {
                alert('Erro interno: dados insuficientes para salvar.');
                return;
            }
            const saving = d3.select('body').append('div')
                .attr('id', 'saving-indicator')
                .style('position', 'fixed')
                .style('bottom', '10px')
                .style('right', '10px')
                .style('background-color', 'rgba(0,0,0,0.7)')
                .style('color', '#fff')
                .style('padding', '5px 10px')
                .style('border-radius', '3px')
                .text('Salvando...');
            const payload = { id: changed.id, impact: changed.impact, difficulty: changed.difficulty };
            fetch('/.netlify/functions/save-data', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            })
                .then(r => {
                    if (!r.ok) return r.json().then(err => { throw new Error(err.error || r.statusText); });
                    return r.json();
                })
                .then(res => {
                    if (res.success) {
                        saving.text('Salvo!').style('background-color', 'rgba(0,128,0,0.7)').transition().delay(1500).remove();
                    } else {
                        alert(`Erro ao salvar dados: ${res.error}`);
                        saving.text('Erro!').style('background-color', 'rgba(200,0,0,0.7)').transition().delay(3000).remove();
                    }
                })
                .catch(e => {
                    alert(`Falha de rede: ${e.message}`);
                    saving.text('Erro!').style('background-color', 'rgba(200,0,0,0.7)').transition().delay(3000).remove();
                });
        }

        // Inicializa tudo
        loadDataAndInitialize();
    </script>
</body>

</html>